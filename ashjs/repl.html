<html>
    <head>
        <title>Ash REPL</title>
        <meta charset="utf8">
        <script type="module" src="./weyland.mjs"></script>
        <script type="module">
            import { Lexer } from "./weyland.mjs";

            var scope = {};

            function react(event)
            {
                if (event.key === 'Enter') {
                    console.log('do validate')
                    let tx = document.getElementById("code");
                    tx.value = tx.value + '\n    ';
                    event.preventDefault();
                }
            }

            function reset()
            {
                let code = document.getElementById("code");
                code.innerText = "";
            }

            function get_end(level, tokens, index)
            {
                let start_level = level
                for (let t = index + 1; t < tokens.length; t++)
                {
                    let tok = tokens[t];
                    if (tok.is('if') || tok.is('while') || tok.is('for'))
                    {
                        level += 1;
                    } else if (tok.is('end') && level == start_level) {
                        return t;
                    } else if (tok.is('end') || tok.is('loop')) {
                        level -= 1
                    }
                }
                // should have an "end" keyword at the end
                throw new Error(`[ERROR] Parser: non-terminated block found at ${index} : ${tokens[index]}.`);
            }

            function get_else(level, tokens, index, end)
            {
                let start_level = level
                for (let t = index + 1; t < tokens.length; t++)
                {
                    let tok = tokens[t];
                    if (tok.is('if') || tok.is('while') || tok.is('for'))
                    {
                        level += 1
                    } else if ((tok.is('else') || tok.is('elif')) && level === 0) {
                        return t;
                    } else if (tok.is('end') && level > 0) {
                        level -= 1;
                    }
                }
                return null;
            }

            function find(tokens, start, value, type, before_end_of_line=false)
            {
                const NOT_FOUND = -1;
                for (let i = start; i < tokens.length; i++)
                {
                    if (tokens[i].is(value, type))
                    {
                        return i;
                    }
                    if (before_end_of_line && tokens[i].is(null, 'newline'))
                    {
                        return NOT_FOUND;
                    }
                }
                return NOT_FOUND;
            }

            class Node
            {

            }

            class Block extends Node
            {
                constructor()
                {
                    this.statements = [];
                }

                add(node)
                {
                    this.statements.push(node);
                }
            }

            class If extends Node
            {

            }

            class While extends Node
            {

            }

            class For extends Node
            {

            }

            class Break extends Node
            {

            }

            class Next extends Node
            {

            }

            class Expression extends Node
            {

            }

            class Parser
            {
                constructor()
                {
                    this.index = 0;
                    this.level = 0;
                    this.tokens = [];
                }

                parse(tokens)
                {
                    this.tokens = tokens;
                    this.parse_block();
                    while (this.index < this.tokens.length)
                    {
                        console.log(`Unhandled token ${tok}`);
                        this.index += 1;
                    }
                }

                parse_scope()
                {
                    // function
                    // procedure
                }

                parse_block()
                {
                    // if
                    // while
                    // for
                    // break
                    // next
                    // expression
                    // affectation
                    // comment
                    // newline
                    let b = new Block();
                    this.level += 1;
                    console.log('    '.repeat(this.level) + `parse block level ${this.level}`);
                    while (this.index < this.tokens.length)
                    {
                        let tok = this.tokens[this.index];
                        if (tok.is('if'))
                        {
                            b.add(this.parse_if());
                        }
                        else if (tok.is(null, 'comment') || tok.is(null, 'newline'))
                        {
                            this.index += 1;
                        }
                        else if (tok.is('break'))
                        {
                            this.index += 1;
                            b.add(new Break());
                        }
                        else if (tok.is('next'))
                        {
                            this.index += 1;
                            b.add(new Next());
                        }
                        else if (tok.is('while'))
                        {
                            b.add(this.parse_while());
                        }
                        else if (tok.is('for'))
                        {
                            b.add(this.parse_for());
                        }
                        else if (tok.is(null, 'identifier') ||
                                 tok.is(null, 'string')     ||
                                 tok.is(null, 'integer')    ||
                                 tok.is(null, 'number')     ||
                                 tok.is(null, 'boolean'))
                        {
                            b.add(this.parse_expr());
                        }
                        else if (tok.is(null, 'newline'))
                        {
                            index += 1;
                        }
                        else
                        {
                            break;
                        }
                    }
                    this.level -= 1;
                    return b;
                }

                read(value, type='keyword', optional=false)
                {
                    // Length check
                    if (this.index >= this.tokens.length)
                    {
                        if (!optional)
                        {
                            throw new Error(`Parse error, unexpected end of stream of tokens, expected ${value}, ${type} @${this.index}.`);
                        }
                        return false;
                    }
                    // Token check on value and/or type
                    const tok = this.tokens[this.index];
                    if (!tok.is(value, type))
                    {
                        if (!optional)
                        {
                            throw new Error(`Parse error, expected ${value}, ${type} @${this.index} got ${tok}`);
                        } else {
                            return false;
                        }
                    }
                    // Display for debug
                    if (value !== null)
                    {
                        console.log('    '.repeat(this.level) + `read ${value} @${this.index}`);
                    } else {
                        console.log('    '.repeat(this.level) + `read ${type} @${this.index}`);
                    }
                    // Forward
                    this.index += 1;
                    return true;
                }

                parse_expr()
                {
                    this.level += 1;
                    console.log('    '.repeat(this.level) + `parse expr at ${this.index}, level ${this.level}`);
                    this.parse_lit();
                    this.level -= 1;
                }

                parse_lit()
                {
                    console.log('    '.repeat(this.level) + `parse literal`)
                    this.read(null, 'boolean');
                }

                parse_if()
                {
                    this.level += 1;
                    console.log('    '.repeat(this.level) + `parse if at ${this.index - 1}, level ${this.level}`);
                    this.parse_expr();
                    this.read('then');
                    this.parse_block();
                    if (this.read('else', 'keyword', true))
                    {
                        this.parse_block();
                    }
                    this.level -= 1;
                    this.read('end');
                }

            }

            function read_while(level)
            {
            }

            function read_for(level)
            {
            }

            function read_aff(level, tokens, start, i_aff)
            {
                console.log('affectation detected');
                let name = read_left_aff(level, tokens, start, i_aff);
                let value = read_right_aff(level, tokens, i_aff);
                scope[name] = value;
            }

            function read_left_aff(level, tokens, start, i_aff)
            {
                console.log(`reading left part of affectation from ${start} to ${i_aff}`);
                if (i_aff - start === 1)
                {
                    return tokens[i_aff - 1].getValue();
                } else {
                    throw new Error("Multiple element left affectation part unsupported.");
                }
            }

            function read_right_aff(level, tokens, start)
            {
                // si on ne trouve pas de newline, on retourne toute la fin
                let end = tokens.length - 1;
                for (let i = start; i < tokens.length; i++)
                {
                    if (tokens[i].is(null, 'newline'))
                    {
                        end = i;
                        break;
                    }
                }
                console.log(`reading right part of affectation from ${start} to ${end}`);
                if (tokens[end].is(null, 'newline'))
                {
                    end -= 1;
                }
                if (end - start === 1)
                {
                    let tok = tokens[start + 1];
                    switch(tok.getType())
                    {
                        case 'integer':
                            return parseInt(tok.getValue());
                        case 'number':
                            return parseFloat(tok.getValue());
                        case 'string':
                            return tok.getValue().slice(1, tok.getValue().length - 1); // Remove the "
                        default:
                            throw new Error("Not handled type : " + tok.getType());
                    }
                } else {
                    throw new Error("Multiple element right affectation part unsupported.");
                }
            }

            function analyse()
            {
                console.clear();
                let code = document.getElementById("code");
                let lex = new Lexer('ash', ['blank']);
                console.log(lex);
                let tokens = [];
                try
                {
                    let output = document.getElementById("output");
                    // Get the code as HTML
                    let text = code.innerHTML;
                    // Removing all <sup>X</sup>
                    text = text.replace(/<sup class="info">[^<]+<\/sup>/gi, "");
                    // Put back the HTML inside the code
                    code.innerHTML = text;
                    // Get again the code but as text (delete all html markup)
                    text = code.innerText.trim();
                    console.log('Input text   |' + text + '|');
                    // Tokenizing
                    tokens = lex.lex(text);
                    let html = '<div>' + lex.to_html(null, tokens, ['blank', 'newline'], true).replaceAll('\n', '</div><div>')  + '</div>';
                    code.innerHTML = html;
                    console.log('HTML         |' + html + '|');
                    //output.innerHTML = lex.to_html(code.innerText, null, ['blank'], true).replaceAll('\n', '<br>');
                    console.log('Tokens       :');
                    for (let tok of tokens)
                    {
                        console.log('    ' + tok.info());
                    }
                } catch (error) {
                    alert(error);
                    return;
                }
                console.log('Parsing :');
                let p = new Parser();
                p.parse(tokens);
                console.log('End of execution');
                console.log(scope);
            }

            document.querySelectorAll('[class$="_reset"]').forEach(e => e.addEventListener('click', reset));
            document.querySelectorAll('[class$="_analyse"]').forEach(e => e.addEventListener('click', analyse));
        </script>
        <link href="https://xitog.github.io/dgx/css/flashy.css" rel="stylesheet">
        <style>
            #code {
                width: 95%;
                height: 90%;
                margin-top: 10px;
                margin-bottom: 10px;
                border: 1px black solid;
                padding: 12px;
                overflow: auto;
                font-family: 'Courier New', Courier, monospace;
                white-space: pre-wrap;
            }
            .grid-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-gap: 5px;
                height: 100%;
            }
            #output {
                margin-top: 30px;
                padding: 12px;
                font-family: 'Courier New', Courier, monospace;
            }
            span[class$=identifier] {
                color: rgb(2,155,238); /*rgb(156, 220, 254);*/
            }
            span[class$=separator] {
                color: rgb(255, 201, 17); /* 197 121 145 */
            }
        </style>
    </head>
    <body width="100%">
        <div class="grid-container">
            <div class="grid-child">
                <button class="_reset">Reset</button>
                <button class="_analyse">Parse</button>
                <div id="code" contenteditable="true"></div>
                <button class="_reset">Reset</button>
                <button class="_analyse">Parse</button>
            </div>
            <div class="grid-child">
                <div id="output"></div>
            </div>
        </div>
    </body>
</html>