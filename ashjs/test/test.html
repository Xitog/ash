<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Ash Live</title>
		<link
			rel="icon"
			href="https://xitog.github.io/dgx/img/favicon.ico"
			type="image/x-icon"
		/>
		<link
			rel="shortcut icon"
			href="https://xitog.github.io/dgx/img/favicon.ico"
			type="image/x-icon"
		/>
		<link
			href="http://fonts.googleapis.com/css?family=Lobster"
			rel="stylesheet"
			type="text/css"
		/>
		<style>
			/* Original tree view css from Ross Angus */

			body {
				font-family: "Courier New", Courier, monospace;
			}

			/* It's supposed to look like a tree diagram */
			.tree,
			.tree ul,
			.tree li,
			.monotree,
			.monotree ul,
			.monotree li {
				list-style: none;
				margin: 0;
				padding: 0;
				position: relative;
			}

			.tree,
			.monotree {
				margin: 0 0 1em;
				text-align: center;
			}
			.tree,
			.tree ul,
			.monotree,
			.monotree ul {
				display: table;
			}
			.tree ul,
			.monotree ul {
				width: 100%;
			}
			.tree li,
			.monotree li {
				display: table-cell;
				padding: 0.5em 0;
				vertical-align: top;
			}
			/* _________ */
			.tree li:before,
			.monotree li:before {
				outline: solid 1px #666;
				content: "";
				left: 0;
				position: absolute;
				right: 0;
				top: 0;
			}
			.tree li:first-child:before,
			.monotree li:first-child:before {
				left: 50%;
			}
			.tree li:last-child:before,
			.monotree li:last-child:before {
				right: 50%;
			}

			.tree code,
			.tree span,
			.monotree code {
				border: solid 0.1em #666;
				border-radius: 0.2em;
				display: inline-block;
				margin: 0 0.2em 0.5em;
				padding: 0.2em 0.5em;
				position: relative;
			}
			/* If the tree represents DOM structure */
			.tree code,
			.monotree code {
				font-family: monaco, Consolas, "Lucida Console", monospace;
			}

			/* | */
			.tree ul:before,
			.tree code:before,
			.tree span:before {
				outline: solid 1px #666;
				content: "";
				height: 0.5em;
				left: 50%;
				position: absolute;
			}
			.tree ul:before {
				top: -0.5em;
			}
			.tree code:before,
			.tree span:before {
				top: -0.55em;
			}

			/* The root node doesn't connect upwards */
			.tree > li {
				margin-top: 0;
			}
			.tree > li:before,
			.tree > li:after,
			.tree > li > code:before,
			.tree > li > span:before {
				outline: none;
			}

			.tree li[data-type="expr"] > code,
			.monotree li[data-type="expr"] > code {
				background-color: #ffcccb;
			}

			h1 {
				font-family: "Lobster", cursive, monospace, "Consolas",
					"Century Gothic";
				color: #4087e4;
				font-size: 32px;
			}

			fieldset {
				width: 620px;
				margin: auto;
			}
		</style>
		<script>
			window.onload = main;

			let language = {
				tokens: {
					op: [
						// Maths
						"+",
						"-",
						"*",
						"/",
						"//",
						"**",
						"%",
						// Booleans
						"not",
						"and",
						"or",
						// Affectation
						"=",
						// Comparisons
						"==",
						"!=",
						"<",
						"<=",
						">=",
						">",
						// List
						",",
					],
					/*
					"%",
					// Specials
					".",
					"<<",
					"#",
					"$",
					// Booleans
					"not",
					"in",
					"is",
				],*/
					sep: ["(", ")", "[", "]"],
					int: [/^[1-9]\d*$/, "0"],
					float: [/^[1-9]\d*\.\d+$/],
					wrong_float: [/^[1-9]\d*\.$/],
					bool: ["true", "false"],
					id: [/^[a-zA-Z_]\w*$/],
					string: [/^"\w*"$/],
					blank: [" "],
				},
				precedences: {
					"(": 9,
					"una-": 8,
					"*": 7,
					"/": 7,
					"//": 7,
					"**": 7,
					"%": 7,
					"+": 6,
					"-": 6,
					">": 5,
					"<": 5,
					">=": 5,
					"<=": 5,
					"==": 5,
					"!=": 5,
					not: 4,
					and: 3,
					or: 3,
					",": 2,
					"=": 1,
				},
			};

			class NilClass {
				toString() {
					return "nil";
				}
			}
			const nil = new NilClass();

			class NodeList {
				constructor() {
					this.nodes = [];
				}
				unshift(n) {
					this.nodes.unshift(n);
				}
				push(n) {
					this.nodes.push(n);
				}
				get(i) {
					return this.nodes[i];
				}
				getList() {
					return this.nodes;
				}
				getSize() {
					return this.nodes.length;
				}
				toString() {
					return `NodeList of ${this.nodes.length} elements`;
				}
			}

			class Node {
				constructor(type, value, left = null, right = null) {
					this.type = type;
					this.value = value;
					this.left = left;
					this.right = right;
				}

				toString() {
					return `(${this.type}, ${this.value})`;
				}

				toHTML() {
					return `${this.value}<sub>${this.type}</sub>`;
				}

				toHTMLTree(isRoot = false) {
					if (this.type !== "expr") {
						if (isRoot) {
							return `<ul class="monotree"><li data-type="${this.type}"><code>${this.value}</code><ul>`;
						} else {
							return `<code>${this.value}</code>`;
						}
					} else {
						let cls = "";
						if (isRoot) {
							cls = ' class="tree"';
						}
						let s = `<ul ${cls}><li data-type="${this.type}"><code>${this.value.value}</code><ul>`;
						s += "<li>" + this.left.toHTMLTree() + "</li>";
						if (this.right !== null) {
							s += "<li>" + this.right.toHTMLTree() + "</li>";
						}
						s += "</ul></li></ul>";
						return s;
					}
				}
			}

			function test(name, code, debug_lex, debug_parse, debug_execute) {
				let nodes = lex(code, debug_lex);
				let container = document.createElement("div");
				// Title
				let title = document.createElement("h1");
				title.innerText = name;
				container.appendChild(title);
				// Input nodes
				let input = document.createElement("pre");
				input.innerHTML = nodes.map((x) => x.toHTML()).join(", ");
				container.appendChild(input);
				// Parsed nodes
				let ns = parse(nodes, debug_parse)[0];
				let root = document.createElement("div");
				container.appendChild(root);
				root.innerHTML = ns.toHTMLTree(true);
				// Result
				let res = document.createElement("pre");
				container.appendChild(res);
				let result = execute(ns, false, debug_execute);
				res.innerHTML = "Result = " + result;
				let boxres = document.getElementById("res");
				boxres.value = result;
				return [container, result];
			}

			function tests(debug = false) {
				let tests = {
					"Test 1": ["2 + 3 * 5", 17],
					"Test 2": ["(2 + 3) * 5", 25],
					"Test 3": ["2 - 5", -3],
					"Test 4": ["9 / 2", 4.5],
					"Test 5": ["9 // 2", 4],
					"Test 6": ["not false and true", true],
					"Test 7": ["a + 0", 5],
					"Test 8": ["4.2", 4.2],
					"Test 9": ['"abc" + "def"', "abcdef"],
				};
				let output = document.getElementById("output");
				for (const [name, content] of Object.entries(tests)) {
					let cmd = content[0];
					let expected = content[1];
					if (debug) {
						console.log("===================================");
						console.log(`${name}: ${cmd}. Expected: ${expected}`);
						console.log("===================================");
					}
					let result = process(name, cmd);
					if (result !== expected) {
						throw new Error(
							`Test error. Expected: ${expected} vs ${result}`
						);
					}
				}
			}

			let scope = {
				a: 5,
				b: 2,
				t: true,
				f: false,
				fun: function (s) {
					console.log(s);
					return s;
				},
				noarg: function () {
					console.log("fonction sans arg");
					return nil;
				},
				add: function (args) {
					if (!(args instanceof NodeList)) {
						throw new Error("Parameters should be a NodeList");
					}
					if (args.getSize() !== 2) {
						throw new Error("Add takes 2 parameters");
					}
					let arg1 = args.get(0);
					let arg2 = args.get(1);
					return arg1 + arg2;
				},
				circle: function (args) {
					console.log("function circle", args);
					// x, y, r, color, full
					if (!(args instanceof NodeList)) {
						throw new Error("Parameters should be a NodeList");
					}
					if (args.getSize() !== 5) {
						throw new Error("Circle takes 5 parameters");
					}
					let centerX = args.get(0);
					let centerY = args.get(1);
					let radius = args.get(2);
					let color = args.get(3);
					let full = args.get(4);
					var canvas = document.getElementById("screen");
					var context = canvas.getContext("2d");
					context.beginPath();
					context.arc(
						centerX,
						centerY,
						radius,
						0,
						2 * Math.PI,
						false
					);
					if (full) {
						context.fillStyle = color;
						context.fill();
					} else {
						context.strokeStyle = color;
						context.stroke();
					}
					return nil;
				},
				rect: function (args) {
					// x y w h color full
					console.log("function rect", args);
					var canvas = document.getElementById("screen");
					var context = canvas.getContext("2d");
					context.fillStyle = args.get(4);
					context.strokeStyle = args.get(4);
					console.log(context.fillStyle);
					if (args.get(5)) {
						context.fillRect(
							args.get(0),
							args.get(1),
							args.get(2),
							args.get(3)
						);
					} else {
						context.strokeRect(
							args.get(0),
							args.get(1),
							args.get(2),
							args.get(3)
						);
					}
				},
			};
			function execute(node, symbol = false, debug = false) {
				if (node.type === "int") {
					return parseInt(node.value);
				} else if (node.type === "float") {
					return parseFloat(node.value);
				} else if (node.type === "bool") {
					return node.value === "true";
				} else if (node.type === "id") {
					if (!symbol) {
						// Function call without parameters
						if (scope[node.value] instanceof Function) {
							let val = scope[node.value]();
							if (val === undefined || val === null) {
								return "nil"; // replace by nil object
							}
							return val;
						}
						return scope[node.value];
					} else {
						return node.value;
					}
				} else if (node.type === "string") {
					return node.value.substring(1, node.value.length - 1);
				} else if (node.type === "expr") {
					let right =
						node.right === null
							? null
							: execute(node.right, false, debug);
					let op = node.value.value;
					// Handling of affectation
					if (op === "=") {
						let symbol = execute(node.left, true, debug);
						if (typeof symbol !== "string") {
							throw new Error(
								"Left part of an affectation should be an identifer"
							);
						}
						scope[symbol] = right;
						return value;
					}
					// Handling of calling
					if (op === "(") {
						let symbol = execute(node.left, true, debug);
						if (typeof symbol !== "string") {
							throw new Error(
								"Left part of a calling should be an identifer"
							);
						}
						if (!(scope[symbol] instanceof Function)) {
							throw new Error(`${symbol} is not a function.`);
						}
						return scope[symbol](right);
					}
					let left = execute(node.left, false, debug);
					// Handling of list
					if (op === ",") {
						if (right instanceof NodeList) {
							right.unshift(left);
							if (debug) {
								console.log("Adding to NodeList", right);
							}
						} else {
							let nx = new NodeList();
							nx.unshift(right);
							nx.unshift(left);
							right = nx;
							if (debug) {
								console.log("Creating new NodeList", right);
							}
						}
						return right;
					}
					// String ---------------------------------------
					if (typeof left === "string") {
						if (op === "+") {
							if (typeof right !== "string") {
								throw new Error(
									"Can only add a string to a string"
								);
							}
							return left + right;
						} else if (op === "*") {
							if (typeof right !== "number") {
								throw new Error(
									"Can only repeat a string by a number"
								);
							}
							return left.repeat(Math.floor(right));
						} else {
							throw new Error(
								`Unsupported operator ${op} for string`
							);
						}
					} else if (typeof left === "number") {
						if (op === "+") {
							return left + right;
						} else if (op === "-") {
							return left - right;
						} else if (op === "*") {
							return left * right;
						} else if (op === "/") {
							return left / right;
						} else if (op === "//") {
							return Math.floor(left / right);
						} else if (op === "**") {
							return Math.pow(left, right);
						} else if (op === "%") {
							return left % right;
						} else if (op === "<") {
							return left < right;
						} else if (op === "<=") {
							return left <= right;
						} else if (op === ">") {
							return left > right;
						} else if (op === ">=") {
							return left >= right;
						} else if (op === "==") {
							return left === right;
						} else if (op === "!=") {
							return left !== right;
						} else if (op === "una-") {
							return -left;
						} else {
							let type = Number.isInteger(left)
								? "integer"
								: "float";
							throw new Error(
								`Unsupported operator ${op} for ${type}`
							);
						}
					} else if (typeof left === "boolean") {
						if (op === "not") {
							return !left;
						} else if (op === "and") {
							return left && right;
						} else if (op === "or") {
							return left || right;
						} else {
							throw new Error(
								`Unsupported operator ${op} for boolean`
							);
						}
					} else {
						throw new Error(`Unsupported type: ${typeof left}`);
					}
				} else {
					throw new Error(
						`Unknown node type |${node.type}| for node ${node}`
					);
				}
			}

			function d(lst) {
				console.log("Affichage liste :");
				for (const [i, e] of lst.entries()) {
					console.log(i, e);
				}
			}

			function parse(nodes, debug) {
				let security = 100;
				while (nodes.length > 1 && security > 0) {
					security -= 1;
					let max = 0;
					let index = null;
					let current_level = 1;
					for (const [i, n] of nodes.entries()) {
						// Selection of the most prioritary operator
						if (
							n.type.startsWith("op") &&
							n.value in language.precedences
						) {
							if (debug) {
								console.log(
									`Test on ${n} with lvl=${current_level} got ${
										language.precedences[n.value] *
										current_level
									} and max=${max}`
								);
							}
							// En cas d'égalité on prend le plus à gauche
							// c'est obligatoire pour les opérateurs unaires
							if (
								language.precedences[n.value] * current_level >=
								max
							) {
								if (debug) {
									console.log("Taken");
								}
								index = i;
								max =
									language.precedences[n.value] *
									current_level;
							}
						}
						// Level of ( ). Warning: ( can be a sep OR a op-bin for call
						// ( add to current level but must be counted as outside
						if (n.value === "(") {
							current_level *= 10;
						} else if (n.value === ")") {
							current_level /= 10;
						}
					}
					if (current_level !== 1) {
						throw new Error(
							`Mismatched parenthesis: ${current_level}`
						);
					}

					if (debug && max !== 0) {
						console.log(
							`Index node chosen @${index} ${nodes[index]} with max=${max}`
						);
					}
					if (max === 0) {
						console.log("ERROR");
						console.log(nodes.join(", "));
						throw new Error(`No operator found`);
					}
					// Perimeter
					let current = nodes[index];
					let left,
						right,
						startDeleteAt,
						deleteLength = null;
					if (["op-bin", "expr"].includes(current.type)) {
						left = nodes[index - 1];
						right = nodes[index + 1];
						startDeleteAt = index - 1;
						deleteLength = 3;
					} else if (current.type === "op-una") {
						left = nodes[index + 1];
						startDeleteAt = index;
						deleteLength = 2;
					} else {
						throw new Error(`Unexpected type: ${current.type}`);
					}
					// Deletion of sep ( )
					if (
						index - 2 >= 0 &&
						nodes[index - 2].value === "(" &&
						nodes[index - 2].type === "sep" && // don't delete ( in function call !
						index + 2 < nodes.length &&
						nodes[index + 2].value === ")"
					) {
						startDeleteAt = index - 2;
						deleteLength += 2;
					}
					// Deletation of sep ) after a calling (
					if (current.type === "op-bin" && current.value === "(") {
						if (
							index + 2 >= nodes.length ||
							nodes[index + 2].type !== "sep" ||
							nodes[index + 2].value !== ")"
						) {
							throw new Error(
								"Calling opening parenthesis not matched" // Should never be called due to Mismatched parenthesis error before
							);
						} else {
							deleteLength += 1;
						}
					}
					if (debug) {
						console.log(
							`Splicing from ${startDeleteAt} with length ${deleteLength}`
						);
					}
					nodes.splice(
						startDeleteAt,
						deleteLength,
						new Node("expr", current, left, right)
					);
					if (debug) {
						d(nodes);
					}
				}
				if (security === 0) {
					throw new Error("Infinite parsing loop, aborting.");
				}
				return nodes;
			}

			function lex(code, debug) {
				let nodes = [];
				let word = "";
				let matches = [];
				let old_matches = [];
				for (let index = 0; index < code.length; index += 1) {
					if (debug) {
						console.log(index);
					}
					if (index > 200) {
						throw new Error("too much");
					}
					let c = code[index];
					word += c;
					if (debug) {
						console.log(`Word is |${word}|`);
					}
					matches = [];
					for (const [t, elems] of Object.entries(language.tokens)) {
						for (const e of elems) {
							let res = false;
							if (e instanceof RegExp) {
								if (e.test(word)) {
									if (debug) {
										console.log(
											`matched ${t} with ${e} for ${word}`
										);
									}
									matches.push(new Node(t, word));
									res = true;
								}
							} else if (e === word) {
								if (debug) {
									console.log(`matched ${t}`);
								}
								matches.push(new Node(t, word));
								res = true;
								break;
							}
							if (debug) {
								console.log(`...against |${e}| = ${res}`);
							}
						}
					}
					if (debug) {
						console.log(
							`Matches: ${matches.length} and old: ${old_matches.length}`
						);
					}
					if (matches.length === 0 && old_matches.length > 0) {
						if (debug) {
							console.log(`Adding node! ${old_matches[0]}`);
						}
						nodes.push(old_matches[0]);
						word = "";
						index -= 1;
					}
					old_matches = matches;
				}
				if (debug) {
					console.log(
						`Matches: ${matches.length} and old: ${old_matches.length}`
					);
				}
				if (word.length > 0) {
					if (old_matches.length > 0) {
						nodes.push(old_matches[0]);
						word = "";
					} else {
						throw new Error(`Unlexed string: |${word}|`);
					}
				}
				// filter blanks
				let nn = [];
				for (const n of nodes) {
					if (n.type !== "blank") {
						nn.push(n);
					}
				}
				nodes = nn;
				// retag nodes
				for (const [i, n] of nodes.entries()) {
					if (n.type === "op") {
						n.type = "op-bin";
						if (n.value === "not") {
							n.type = "op-una";
						} else if (n.value === "-") {
							if (i == 0) {
								n.type = "op-una";
								n.value = "una-";
							} else if (i - 1 >= 0) {
								if (
									["sep", "op-bin", "op-una"].includes(
										nodes[i - 1].type
									)
								) {
									n.type = "op-una";
									n.value = "una-";
								}
							}
						}
					} else if (n.type === "sep") {
						if (i - 1 >= 0) {
							if (nodes[i - 1].type === "id") {
								n.type = "op-bin";
							}
						}
					}
				}
				if (debug) {
					console.log("End of lexing", code);
					d(nodes);
				}
				return nodes;
			}

			function clickprocess() {
				let code = document.main.cmd.value;
				process(">>>", code);
			}

			function process(name, code) {
				let output = document.getElementById("output");
				let debug_lex = document.getElementById("debug_lex").checked;
				let debug_parse =
					document.getElementById("debug_parse").checked;
				let debug_execute =
					document.getElementById("debug_execute").checked;
				let res = test(
					name,
					code,
					debug_lex,
					debug_parse,
					debug_execute
				);
				let container = res[0];
				let result = res[1];
				output.prepend(container); // appendChild
				return result;
			}

			function main() {
				let input = document.getElementById("cmd");
				input.addEventListener("keydown", function (event) {
					if (event.key === "Enter") {
						event.preventDefault();
						document.getElementById("go").click();
					}
				});
				tests(false);
			}
		</script>
	</head>
	<body>
		<div
			style="text-align: center; padding-top: 70px; padding-bottom: 70px"
		>
			<h1>Ash</h1>
			<form name="main">
				<fieldset>
					<legend>Type your expression</legend>
					<input id="cmd" type="text" size="60" />
					<input
						id="go"
						type="button"
						value="Run"
						onclick="clickprocess()"
					/>
					<input
						id="res"
						type="text"
						disabled
						style="background-color: gainsboro"
					/>
				</fieldset>
				<fieldset>
					<legend>Debug</legend>
					<input
						id="debug_lex"
						name="debug_lex"
						type="checkbox"
						onchange="console.clear()"
					/>
					<label for="debug_lex">Lex</label>
					<input
						id="debug_parse"
						name="debug_parse"
						type="checkbox"
						onchange="console.clear()"
					/>
					<label for="debug_parse">Parse</label>
					<input
						id="debug_execute"
						name="debug_execute"
						type="checkbox"
						onchange="console.clear()"
					/>
					<label for="debug_execute">Execute</label>
				</fieldset>
			</form>
			<canvas
				id="screen"
				width="640"
				height="480"
				style="border: 1px solid black; margin-top: 1em"
			></canvas>
			<div id="output"></div>
		</div>
	</body>
</html>
